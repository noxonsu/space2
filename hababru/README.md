# B2B Платформа для Кастомных Решений с SEO-Фокусом

## Описание Проекта

Данная платформа представляет собой B2B-сервис, специализирующийся на разработке кастомных решений для бизнеса. Основная цель — привлечение клиентов через SEO-оптимизированные демонстрационные сервисы, которые показывают экспертизу команды в различных отраслях.

### Ключевые Направления:
- **Анализ юридических документов** - Демонстрационный сервис для проверки договоров с AI-анализом
- **Мониторинг отраслевых новостей** - Система отслеживания упоминаний и анализа новостей (например, ВЭД)
- **Кастомные B2B-решения** - Разработка под конкретные задачи клиентов

### Архитектура Платформы:
Платформа построена на принципе **SEO-first подхода**, где каждый демонстрационный сервис окружен семантическим ядром целевых страниц для привлечения органического трафика и демонстрации экспертности.

### Текущий Модуль: Анализ Договоров
Пользователь загружает текст договора (PDF/DOC), система асинхронно анализирует каждый пункт/абзац с помощью LLM, отображая потенциальные риски, рекомендации и связи между разделами документа.

Сервис использует универсальный LLM-коннектор (DeepSeek/OpenAI), кэширует результаты для производительности и генерирует SEO-оптимизированные страницы для каждого типа договоров.

## Запуск Приложения

Для запуска Flask-application выполните следующие шаги:

1.  **Установите зависимости:**
    ```bash
    pip install -r requirements.txt
    ```
2.  **Настройте переменные окружения:**
    Скопируйте `.env.example` в `.env` и заполните необходимые API-ключи и другие параметры.
    ```bash
    cp .env.example .env
    ```
3.  **Запустите приложение:**
    ```bash
    python -m src.backend.main
    ```
    Приложение будет доступно по адресу `http://127.0.0.1:5001`.
    
    **Важно:** Если вы работаете в Codespaces, приложение будет доступно по динамическому URL, который Codespaces предоставляет для порта 5001.

## Работа в Codespaces и Тестирование

### Основная среда разработки
Мы работаем преимущественно в **GitHub Codespaces**. Это означает, что приложения должны быть настроены для работы в облачной среде, а не на локальной машине.

**Ключевые моменты:**
- **Сетевые настройки:** Приложения должны запускаться на `0.0.0.0`, чтобы быть доступными извне контейнера.
- **URL и порты:** Вместо `localhost` используйте динамически генерируемые URL, которые предоставляет Codespaces. Для этого используйте переменные окружения, такие как `CODESPACE_NAME` и `GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN`.
- **Автоматизация:** Настройте скрипты так, чтобы они автоматически определяли, что запущены в Codespaces, и применяли соответствующие конфигурации.

### Процесс тестирования
1.  **Создание тестов:** При добавлении нового функционала сначала пишите тесты (TDD). Для Python-проектов используйте `pytest`.
2.  **Структура тестов:** Размещайте тесты в папке `tests/` в корне проекта.
3.  **Запуск тестов:** Перед завершением любой задачи убедитесь, что все тесты успешно проходят. Запускайте тесты командой:
    ```bash
    pytest tests/
    ```
4.  **Интеграционное тестирование:** Убедитесь, что компоненты системы (например, фронтенд и бэкенд) корректно взаимодействуют друг с другом в среде Codespaces.

## Технологический Стек

*   **Бэкенд**: Python (Flask)
    *   Парсинг документов: `pdfminer.six`, `python-docx`
    *   Взаимодействие с API: `requests`
    *   Кэширование: Файловая система (JSON)
    *   Шаблонизатор: Jinja2
*   **Фронтенд**: Vanilla JavaScript
*   **AI/LLM**: Универсальный коннектор (DeepSeek/OpenAI)
*   **SEO**: Автоматическая генерация контента и метаданных
*   **Контент**: Markdown с YAML Front Matter
*   **Мониторинг**: Интеграция с внешними API для отслеживания новостей

## Модульная Архитектура

Платформа построена по модульному принципу, где каждый бизнес-сервис является отдельным модулем:

### Модуль 1: Анализ Договоров (`/hababru/`)
- **Цель**: Демонстрация экспертизы в юридтехе
- **Функционал**: AI-анализ договоров, выявление рисков, рекомендации
- **SEO**: Страницы под типы договоров (аренда, поставка, ипотека, etc.)

### Модуль 2: Мониторинг Новостей (`/newsalert/`)
- **Цель**: Демонстрация экспертизы в анализе данных и мониторинге
- **Функционал**: Отслеживание упоминаний, анализ отраслевых новостей
- **SEO**: Страницы под отраслевые темы (ВЭД, логистика, etc.)

### Будущие Модули:
- **Финтех-решения**: Анализ финансовых показателей
- **HR-автоматизация**: Обработка резюме и документооборот
- **Аналитические дашборды**: Визуализация бизнес-метрик

## Центральная SEO-Система

Все модули объединены центральной SEO-системой для максимального покрытия семантического ядра:

## Структура Проекта

```
hababru/
├── .env                      # Переменные окружения (API ключи, токены)
├── .gitignore                # Игнорируемые файлы и директории для Git
├── .pytest_cache/            # Кэш pytest
├── .wakatime-project         # Файл конфигурации Wakatime
├── .wata                     # Вспомогательный файл (возможно, для внутренних нужд)
├── README.md                 # Описание проекта, структура, план работы, инструкции
├── TGStat API.postman_collection.json # Коллекция Postman для работы с TGStat API
├── content/                  # Исходные файлы контента
│   ├── __init__.py           # Инициализация Python-пакета
│   ├── llm_results/          # Результаты работы LLM-промптов
│   │   └── *.txt             # Файлы с результатами LLM-промптов
│   ├── seo_pages/            # Директория для SEO-страниц в формате .md
│   │   ├── __init__.py       # Инициализация Python-пакета
│   │   ├── [slug]/           # Директория для каждой SEO-страницы (например, arendy, dareniya)
│   │   │   ├── generated_contract.txt # Сгенерированный текст договора для страницы
│   │   │   └── source.md     # Метаданные и основной текст страницы
│   │   └── ...               # Другие SEO-страницы (по одной на каждый ключ)
│   └── seo_prompts/          # Шаблоны промптов для генерации SEO-контента
│       └── *.txt             # Файлы с шаблонами промптов
├── data/                     # Хранилище данных
│   ├── __init__.py           # Инициализация Python-пакета
│   ├── cache/                # Кэш договоров и анализов (например, JSON файлы)
│   │   └── __init__.py       # Инициализация Python-пакета
│   ├── uploads/              # Временно загруженные файлы
│   │   └── __init__.py       # Инициализация Python-пакета
│   └── sample_contracts/     # Примеры договоров
│       ├── __init__.py       # Инициализация Python-пакета
│       └── default_nda.txt   # Пример договора по умолчанию
├── deepseek_api_docs.md      # Документация по DeepSeek API
├── dubna.docx                # Пример DOCX файла (возможно, для тестирования парсинга)
├── public/                   # Статические ресурсы и скомпилированный фронтенд
│   ├── css/                  # Стили CSS
│   │   └── style.css         # Основной файл стилей
│   ├── favicon.ico           # Иконка сайта
│   ├── js/                   # Клиентские скрипты JavaScript
│   │   ├── app.js            # Основная логика фронтенда
│   │   └── seo_admin.js      # Скрипты для страницы администрирования SEO
│   └── robots.txt            # Файл для поисковых роботов
├── pytest.ini                # Конфигурационный файл pytest
├── pytest_output.txt         # Вывод результатов выполнения pytest
├── requirements.txt          # Зависимости Python
├── semantix.txt              # Файл с семантическими запросами (возможно, для SEO)
├── src/                      # Исходный код
│   ├── backend/              # Логика бэкенда (Python)
│   │   ├── __init__.py       # Инициализация Python-пакета
│   │   ├── __pycache__/      # Кэш скомпилированных Python-файлов
│   │   ├── api/              # API эндпоинты
│   │   │   ├── __init__.py   # Инициализация Python-пакета
│   │   │   ├── __pycache__/  # Кэш скомпилированных Python-файлов
│   │   │   └── v1/
│   │   │       ├── __init__.py # Инициализация Python-пакета
│   │   │       ├── __pycache__/ # Кэш скомпилированных Python-файлов
│   │   │       ├── contract_analyzer.py # Эндпоинт для анализа договоров
│   │   │       └── seo_tools.py      # Эндпоинты для администрирования SEO
│   │   ├── cli/              # Скрипты командной строки
│   │   │   ├── __init__.py   # Инициализация Python-пакета
│   │   │   └── generate_seo_page.py # Скрипт для генерации SEO-страниц
│   │   ├── main.py           # Точка входа бэкенд-приложения
│   │   ├── services/         # Бизнес-логика
│   │   │   ├── __init__.py   # Инициализация Python-пакета
│   │   │   ├── __pycache__/  # Кэш скомпилированных Python-файлов
│   │   │   ├── cache_service.py    # Логика кэширования
│   │   │   ├── content_generation_service.py # Сервис для генерации контента
│   │   │   ├── llm_service.py      # Универсальный LLM-коннектор
│   │   │   ├── parsing_service.py  # Парсинг PDF/DOC
│   │   │   ├── seo_prompt_service.py # Сервис для работы с промптами SEO
│   │   │   └── seo_service.py      # Сервис для работы с SEO-страницами
│   │   ├── templates/        # HTML-шаблоны Jinja2
│   │   │   ├── index_template.html # Единый шаблон для всех страниц
│   │   │   └── seo_admin_template.html # Шаблон для страницы администрирования SEO
│   │   └── utils/            # Вспомогательные функции
│   │       └── __init__.py   # Инициализация Python-пакета
│   ├── data/                 # Директория для данных (например, загруженных файлов)
│   │   └── uploads/          # Временно загруженные файлы
│   ├── frontend/             # Исходный код фронтенда
│   │   ├── __init__.py       # Инициализация Python-пакета
│   │   ├── components/       # UI компоненты
│   │   │   └── __init__.py   # Инициализация Python-пакета
│   │   └── services/         # Сервисы фронтенда (вызовы API)
│   │       └── __init__.py   # Инициализация Python-пакета
│   └── shared/               # Общий код для фронтенда и бэкенда
│       └── __init__.py       # Инициализация Python-пакета
├── tests/                    # Автоматизированные тесты
│   ├── test_api.py           # Тесты для API эндпоинтов
│   ├── test_cache_service.py # Тесты для сервиса кэширования
│   ├── test_llm_service.py   # Тесты для LLM-сервиса
│   ├── test_parsing_service.py # Тесты для сервиса парсинга
│   ├── test_seo_admin.py     # Тесты для администрирования SEO
│   ├── test_seo_prompt_api.py # Тесты для API запуска промптов SEO
│   └── test_seo_service.py   # Тесты для SEO-сервиса
└── tree.txt                  # Файл с древовидной структурой проекта
```

## План Работы (Выполнено)

1.  **Инициализация Проекта:**
    *   Создана корневая директория `hababru/`.
    *   Создана базовая структура папок внутри `hababru/`.
    *   Создан файл `hababru/.env` с `DEEPSEEK_API_KEY`, `YANDEX_CLIENT_ID`, `YANDEX_CLIENT_SECRET`, `YANDEX_REDIRECT_URI`.
    *   Создан файл `hababru/README.md` с этим подробным описанием.
    *   Подготовлен файл `data/sample_contracts/default_nda.txt` с примером договора.
    *   Созданы все необходимые `__init__.py` файлы для корректной работы пакетов Python.
    *   Установлены зависимости из `requirements.txt`.

2.  **Разработка Бэкенда (Python с Flask):**
    *   Настроен Flask-фреймворк и реализован `src/backend/main.py` как точка входа.
    *   **Обновлено**: Рефакторинг `src/backend/main.py` для использования функции `create_app()` для инициализации Flask приложения. Это позволяет создавать чистые экземпляры приложения для каждого тестового запуска.
    *   Реализован `src/backend/services/parsing_service.py` для парсинга PDF/DOCX и сегментации текста на пункты/абзацы.
    *   Реализован `src/backend/services/llm_service.py` как универсальный LLM-коннектор, поддерживающий DeepSeek и OpenAI API.
    *   **Обновлено**: Реализован `src/backend/services/cache_service.py` для кэширования результатов анализа и управления статусом асинхронных задач.
    *   **Обновлено**: Реализован `src/backend/api/v1/contract_analyzer.py` с API-эндпоинтами `/upload_contract`, `/start_analysis` (для запуска асинхронного анализа), `/get_analysis_status/<task_id>` (для получения прогресса) и `/get_sample_contract`.
    *   **Обновлено**: Рефакторинг `src/backend/api/v1/seo_tools.py` для использования функции `create_seo_tools_blueprint()`, что позволяет избежать конфликтов при регистрации эндпоинтов в тестах.
    *   Blueprint `contract_analyzer_bp` зарегистрирован в `main.py`.
    *   **Обновлено**: Главная страница и SEO-страницы теперь рендерятся с использованием единого шаблона `src/backend/templates/index_template.html`.

3.  **Разработка Фронтенда (Vanilla JS):**
    *   Статический файл `public/index.html` удален. Главная страница теперь рендерится бэкендом.
    *   Создан `public/css/style.css` для общих стилей.
    *   **Обновлено**: Создан `public/js/app.js` с единой логикой для главной и SEO-страниц:
        *   Добавлен `public/favicon.ico`.
        *   Рандомизация реквизитов примера договора.
        *   Загрузка примера договора через API `/api/v1/get_sample_contract`.
        *   Отображение текста договора по пунктам/абзацам.
        *   Базовая логика для отображения панели анализа при наведении.
        *   Обработчик для загрузки пользовательских файлов и отправки их на анализ.
        *   **Новое**: Реализован асинхронный запуск анализа через `/api/v1/start_analysis`.
        *   **Новое**: Добавлена логика периодического опроса `/api/v1/get_analysis_status/<task_id>` для отображения прогресса анализа (количество обработанных пунктов/абзацев и процент выполнения).
        *   **Новое**: Добавлены элементы UI (текстовое поле и прогресс-бар) для визуализации прогресса.
    *   **Новое**: На главную страницу (теперь через `index_template.html`) добавлен текст о сервисе и ссылки на существующие SEO-страницы договоров.

5.  **Унификация шаблонов и стилей:**
    *   Удален шаблон `src/backend/templates/seo_page_template.html`.
    *   Все страницы теперь используют единый шаблон `src/backend/templates/index_template.html`.
    *   Стили унифицированы в `public/css/style.css`.
    *   JavaScript-логика унифицирована в `public/js/app.js`.

6.  **Тестирование и Отладка:**
    *   Проверена базовая структура проекта и установка зависимостей.
    *   Проверена работа Flask-приложения и обслуживание статических файлов.
    *   Проверена загрузка примера договора через API.
    *   **Обновлено**: Проверена асинхронная работа анализа и отображение прогресса на фронтенде.
    *   **Обновлено**: Автотесты были рефакторингованы для использования `create_app()` и передачи моков сервисов, что решило проблемы с перезаписью эндпоинтов и некорректным мокированием.
    *   **Обновлено**: Исправлена ошибка `TypeError: a bytes-like object is required, not 'str'` в `test_get_sample_contract` путем изменения `read_data` в `mock_open` на байтовую строку.
    *   **Обновлено**: Оптимизировано выполнение `test_seo_page_ipotechnyh_dogovorov_content_display` путем мокирования `analysis_results_raw` с ограниченным количеством пунктов, чтобы избежать долгого анализа.

## Текущий Статус и Известные Проблемы

Все файлы проекта, включая бэкенд-сервисы, API-эндпоинты и базовый фронтенд, созданы согласно плану. Асинхронный анализ и отображение прогресса реализованы.

### Обновления по передаче данных на SEO-страницы

*   **Улучшена передача данных на SEO-страницы**: Передача данных `appConfig` из бэкенда на фронтенд для SEO-страниц была переработана для повышения надежности. Теперь данные сериализуются в JSON на стороне Python (`src/backend/services/seo_service.py`) и передаются в скрытый `div` в `src/backend/templates/index_template.html`. Фронтенд (`public/js/app.js`) считывает эти данные из `textContent` этого `div` и парсит их как JSON. Это устраняет проблемы с экранированием символов и обеспечивает корректную инициализацию `window.appConfig`.
*   **Обновлены автотесты**: Соответствующие автотесты (`tests/test_api.py`) были обновлены для проверки нового механизма передачи данных, включая извлечение и парсинг JSON из HTML-ответа.

### Исправленные проблемы

*   **Исправлен `test_get_llm_models`**: Проблема, из-за которой тест `test_get_llm_models` завершался неудачей (возвращал `None` вместо списка моделей), была устранена путем добавления оператора `return unique_models` в конце функции `get_available_models` в `src/backend/services/llm_service.py`.
*   **Удален дублирующийся код в `llm_service.py`**: Из `src/backend/services/llm_service.py` был удален дублирующийся блок кода, что повысило читаемость и поддерживаемость файла.
*   **Исправлен `test_seo_page_content_display`**: Проблема с отображением контента на SEO-страницах, которая приводила к ошибке в `test_seo_page_content_display`, была решена путем изменения логики инициализации `window.appConfig` в `src/backend/templates/index_template.html`. Теперь данные из скрытого `div` парсятся в `window.appConfig` до загрузки `app.js`, что гарантирует их доступность. Также была удалена дублирующая логика парсинга `app-config-data` и дублирующая функция `loadTestContractAndAnalyze` из `public/js/app.js`.

## Новые Возможности (Реализовано)

### 1. Система Продуктов на YAML

Переведена с хардкода на файловую конфигурацию:

- **Структура**: `content/products/` - директория с YAML-файлами продуктов
- **Загрузчик**: `ProductDataLoader` - сервис для загрузки и валидации YAML-конфигов
- **Продукты**: `NewsAnalysisProduct`, `ContractAnalysisProduct` - обновлены для работы с YAML

Пример YAML-конфига:
```yaml
name: "Анализ Договоров"
slug: "contract_analysis"
description: "AI-анализ юридических документов с выявлением рисков"
category: "legaltech"
features:
  - "Автоматический парсинг PDF/DOCX"
  - "AI-анализ каждого пункта"
  - "Выявление потенциальных рисков"
api:
  endpoints:
    - path: "/api/v1/upload_contract"
      method: "POST"
      description: "Загрузка и анализ договора"
```

### 2. Поддержка llms.txt

Реализована генерация машиночитаемого описания платформы согласно спецификации [llmstxt.org](https://llmstxt.org/):

- **Сервис**: `LlmsTxtService` - генерирует структурированное описание
- **Маршрут**: `/llms.txt` - автоматически доступный endpoint
- **Содержимое**: Описание продуктов, API, возможностей платформы

### 3. Telegram Интеграция

Автоматическое создание новых продуктов из сообщений Telegram-канала:

- **TelegramConnector** - подключение к каналу @aideaxondemos
- **TelegramProductGenerator** - генерация YAML-конфигов через LLM
- **TelegramMonitor** - фоновый мониторинг новых сообщений
- **CLI**: `src/backend/cli/telegram_monitor.py` - ручной запуск

#### Настройка Telegram мониторинга:

1. Получите API credentials из [my.telegram.org](https://my.telegram.org)
2. Добавьте в `.env`:
```bash
# Telegram API
TELEGRAM_API_ID=your_api_id
TELEGRAM_API_HASH=your_api_hash
TELEGRAM_PHONE_NUMBER=your_phone
ENABLE_TELEGRAM_MONITORING=true
TELEGRAM_CHECK_INTERVAL=300  # секунды (5 минут)
```

3. Первый запуск (для авторизации):
```bash
cd src/backend/cli
python telegram_monitor.py
```

4. Автоматический мониторинг запускается при старте приложения

#### Как работает:
1. Мониторинг отслеживает новые сообщения в @aideaxondemos
2. LLM анализирует текст и изображения из сообщения  
3. Генерируется YAML-конфиг нового продукта
4. Файл автоматически сохраняется в `content/products/`
5. Продукт становится доступен в системе

### 4. Тестирование

Все новые возможности покрыты автотестами:

- `tests/test_product_data_loader.py` - тесты загрузчика YAML
- `tests/test_llms_txt.py` - тесты генерации llms.txt  
- `tests/test_telegram_product_generator.py` - тесты генерации продуктов
- `tests/test_telegram_connector.py` - тесты Telegram API

Запуск всех тестов:
```bash
pytest tests/ -v
```

## Технологический Стек

*   **Бэкенд**: Python (Flask)
    *   Парсинг документов: `pdfminer.six`, `python-docx`
    *   Взаимодействие с API: `requests`
    *   Кэширование: Файловая система (JSON)
    *   Шаблонизатор: Jinja2
*   **Фронтенд**: Vanilla JavaScript
*   **AI/LLM**: Универсальный коннектор (DeepSeek/OpenAI)
*   **SEO**: Автоматическая генерация контента и метаданных
*   **Контент**: Markdown с YAML Front Matter
*   **Мониторинг**: Интеграция с внешними API для отслеживания новостей

## Обновления и Исправления

### 1. Удаление `/demo/` из ссылок на продукты
- **Файл**: `hababru/public/js/app.js`
- **Изменение**: Удален префикс `/demo/` из URL-адресов продуктов, чтобы ссылки вели напрямую к страницам продуктов (например, `/product_id` вместо `/demo/product_id`).

### 2. Объяснение значения `other` в категориях продуктов
- В файле `hababru/src/backend/api/v1/seo_tools.py` (функция `get_existing_products`) и `hababru/src/backend/main.py` (функция `get_products_list`) значение `'other'` используется как категория по умолчанию для продуктов, у которых явно не указана категория в их конфигурации. Это позволяет классифицировать продукты, не имеющие специфической категории.

### 3. Исправление ошибок 404 в админке
- **Проблема**: Запросы к API `/api/v1/seo_pages_list` и `/api/v1/products/stats` возвращали ошибку 404.
- **Причина**: Blueprint `seo_tools` был зарегистрирован в `main.py` с префиксом `/admin`, что означало, что все его эндпоинты должны были вызываться с `/admin/` в начале пути (например, `/admin/seo_pages_list`). Фронтенд же продолжал использовать старые пути (`/api/v1/`).
- **Исправление**:
    - **Файл**: `hababru/public/js/seo_admin.js`
    - **Изменение**: Обновлены пути запросов к `/admin/seo_pages_list` и `/admin/get_llm_models`.
    - **Файл**: `hababru/src/backend/templates/admin/dashboard.html`
    - **Изменение**: Обновлены пути запросов к `/admin/seo_pages_list` и `/admin/products/stats`.

### 4. Проблема с таймаутом LLM-сервиса
- **Проблема**: Тест `tests/test_arendy_page.py` завершается с ошибкой `Timeout` во время вызова `llm_service.analyze_paragraph_in_context`.
- **Анализ**: Это указывает на то, что LLM-сервис не отвечает в течение установленного времени. Причины могут быть различными: высокая нагрузка на LLM API, проблемы с сетью, или слишком сложный запрос, требующий больше времени для обработки.
- **Предпринятые действия**:
    - **Файл**: `hababru/src/backend/services/llm_service.py`
    - **Изменение**: Увеличен таймаут для `generate_text` до 300 секунд и для `analyze_paragraph_in_context` до 600 секунд.
    - **Изменение**: Исправлена опечатка в названии модели `gpt-3.5-тurbo` на `gpt-3.5-turbo` в функции `_get_openai_models`.
- **Статус**: Несмотря на увеличение таймаутов, проблема сохраняется. Это указывает на то, что проблема, вероятно, находится вне контроля приложения (например, в доступности внешнего LLM API). Для дальнейшего решения этой проблемы потребуется дополнительная диагностика внешнего LLM API или рассмотрение альтернативных LLM-провайдеров/моделей.

### 5. Добавление простейшего сборщика логов из браузера
- **Функционал**: Реализован механизм для сбора ошибок JavaScript из браузера и их сохранения в файл на сервере.
- **Реализация**:
    - **Бэкенд**: Создан новый Blueprint `browser_log_bp` в `hababru/src/backend/api/v1/browser_log.py` с эндпоинтом `/log_browser_error`. Этот Blueprint зарегистрирован в `hababru/src/backend/main.py` с префиксом `/api/v1/`, делая его общедоступным. Старый эндпоинт из `hababru/src/backend/api/v1/seo_tools.py` удален. В эндпоинт `log_browser_error` добавлено дополнительное логирование для отладки.
    - **Фронтенд**: В `hababru/public/js/app.js` глобальный обработчик `window.onerror` был перемещен за пределы `DOMContentLoaded` и других функций, чтобы гарантировать его однократную и корректную регистрацию. Он перехватывает необработанные ошибки JavaScript и отправляет их на новый общедоступный бэкенд-эндпоинт `/api/v1/log_browser_error`. В `hababru/src/backend/templates/admin/base.html` также добавлен глобальный обработчик `window.onerror` для страниц админки.
    - **Тестовая кнопка**: В `hababru/src/backend/templates/index_template.html` добавлена кнопка "Вызвать тестовую ошибку", которая при нажатии намеренно вызывает ошибку JavaScript, чтобы проверить работу сборщика логов.
- **Файл логов**: Ошибки браузера будут записываться в `hababru/logs/browser.log`.

## Рекомендации для дальнейшей работы

- **Доступ к админке на продакшене**: На продакшене доступ к `/admin` закрыт формой логина. Это означает, что все API-эндпоинты, предназначенные для использования на публичной части сайта, должны быть вынесены из Blueprint'а `/admin` в общедоступные Blueprint'ы (например, `/api/v1/`), как это было сделано для сборщика логов браузера.
- **Диагностика LLM-сервиса**: Если проблема с таймаутом LLM-сервиса сохраняется, рекомендуется провести более глубокую диагностику доступности и производительности используемых LLM API (DeepSeek, OpenAI). Возможно, потребуется связаться с поддержкой провайдера или рассмотреть использование локальных LLM-моделей для тестирования.
- **Мониторинг логов**: Включить более детальное логирование запросов к LLM API для выявления конкретных причин таймаутов (например, статус-коды ответов, время ответа).
- **Оптимизация промптов**: Проверить промпты, используемые для анализа, на предмет их сложности. Возможно, их можно упростить, чтобы сократить время ответа LLM.
- **Обработка ошибок LLM**: Улучшить обработку ошибок LLM-сервиса, чтобы приложение могло корректно реагировать на таймауты и другие проблемы, не приводя к полному сбою.
- **Просмотр логов браузера**: Регулярно проверять файл `hababru/logs/browser.log` для выявления и устранения ошибок на стороне клиента.
